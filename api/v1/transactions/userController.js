const prisma = require('@/lib/prisma');

/**
 * Get User Profile & Balance
 * Fetches data from the User table and the associated Wallet record
 */
const getProfile = async (req, res) => {
    try {
        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: {
                id: true,
                fullName: true,
                email: true,
                phoneNumber: true,
                tier: true,
                isKycVerified: true,
                createdAt: true,
                wallet: {
                    select: {
                        balance: true,
                        bonusBalance: true,
                        totalSpent: true
                    }
                }
            }
        });

        if (!user) return res.status(404).json({ status: "ERROR", message: "User not found" });

        const responseData = {
            ...user,
            walletBalance: user.wallet?.balance || 0,
            bonusBalance: user.wallet?.bonusBalance || 0,
            totalSpent: user.wallet?.totalSpent || 0,
            wallet: undefined 
        };

        return res.status(200).json({ status: "OK", data: responseData });
    } catch (error) {
        return res.status(500).json({ status: "ERROR", message: "Internal server error" });
    }
};

/**
 * Get Transaction History (Paginated)
 */
const getTransactions = async (req, res) => {
    try {
        const { page = 1, limit = 10, type } = req.query;
        const skip = (page - 1) * limit;

        const where = { userId: req.user.id };
        if (type) where.type = type;

        const [transactions, total] = await prisma.$transaction([
            prisma.transaction.findMany({
                where,
                orderBy: { createdAt: 'desc' },
                skip: parseInt(skip),
                take: parseInt(limit),
                include: {
                    printedPins: true 
                }
            }),
            prisma.transaction.count({ where })
        ]);

        return res.status(200).json({
            status: "OK",
            data: transactions,
            pagination: {
                total,
                page: parseInt(page),
                limit: parseInt(limit),
                totalPages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        return res.status(500).json({ status: "ERROR", message: "Failed to fetch transactions" });
    }
};

/**
 * Dashboard Overview
 * Aggregates user info, wallet balance, and recent activity
 * Fixed: Today Spent now excludes WALLET_FUNDING types
 */
const getDashboard = async (req, res) => {
    try {
        const userId = req.user.id;

        const [userWithWallet, recentTransactions, stats] = await prisma.$transaction([
            // 1. User Info including the decoupled Wallet
            prisma.user.findUnique({
                where: { id: userId },
                select: { 
                    fullName: true, 
                    tier: true,
                    wallet: { select: { balance: true, totalSpent: true } }
                }
            }),
            // 2. Last 5 Transactions
            prisma.transaction.findMany({
                where: { userId },
                orderBy: { createdAt: 'desc' },
                take: 5
            }),
            // 3. Stats (Spent Today)
            // Fix: Exclude WALLET_FUNDING from "spent" calculation
            prisma.transaction.aggregate({
                where: {
                    userId,
                    status: 'SUCCESS',
                    type: { not: 'WALLET_FUNDING' }, // Only count actual purchases
                    createdAt: { gte: new Date(new Date().setHours(0, 0, 0, 0)) }
                },
                _sum: { amount: true }
            })
        ]);

        return res.status(200).json({
            status: "OK",
            data: {
                user: {
                    fullName: userWithWallet.fullName,
                    tier: userWithWallet.tier,
                    walletBalance: userWithWallet.wallet?.balance || 0,
                    lifetimeSpent: userWithWallet.wallet?.totalSpent || 0
                },
                recentTransactions,
                todaySpent: stats._sum.amount || 0
            }
        });
    } catch (error) {
        console.error("Dashboard Error:", error);
        return res.status(500).json({ status: "ERROR", message: "Dashboard error" });
    }
};

/**
 * GET /pins
 * Returns a general inventory of all pins generated by the user
 */
const getUserPins = async (req, res) => {
    try {
        const { page = 1, limit = 20, network } = req.query;
        const skip = (page - 1) * limit;

        const where = {
            transaction: {
                userId: req.user.id
            }
        };

        if (network) where.network = network.toUpperCase();

        const [pins, total] = await prisma.$transaction([
            prisma.rechargePin.findMany({
                where,
                orderBy: { createdAt: 'desc' },
                skip: parseInt(skip),
                take: parseInt(limit),
                include: {
                    transaction: {
                        select: { reference: true, createdAt: true }
                    }
                }
            }),
            prisma.rechargePin.count({ where })
        ]);

        return res.status(200).json({
            status: "OK",
            data: pins,
            pagination: {
                total,
                page: parseInt(page),
                limit: parseInt(limit),
                totalPages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        return res.status(500).json({ status: "ERROR", message: "Failed to fetch pin inventory" });
    }
};

/**
 * GET /transactions/:reference/pins
 */
const getTransactionPins = async (req, res) => {
    const { reference } = req.params;

    try {
        const transaction = await prisma.transaction.findUnique({
            where: { reference },
            include: {
                printedPins: true
            }
        });

        if (!transaction || transaction.userId !== req.user.id) {
            return res.status(404).json({ status: "ERROR", message: "Transaction not found" });
        }

        return res.status(200).json({
            status: "OK",
            data: {
                orderId: transaction.reference,
                date: transaction.createdAt,
                amount: transaction.amount,
                quantity: transaction.metadata?.quantity || transaction.printedPins.length,
                network: transaction.metadata?.network,
                denomination: transaction.metadata?.faceValue,
                pins: transaction.printedPins
            }
        });
    } catch (error) {
        return res.status(500).json({ status: "ERROR", message: "Error retrieving order pins" });
    }
};

module.exports = { 
    getProfile, 
    getTransactions, 
    getDashboard, 
    getUserPins, 
    getTransactionPins 
};